<!doctype html>
<!-- SPDX-FileCopyrightText: 2023 Steffen Vogel <post@steffenvogel.de>
SPDX-License-Identifier: Apache-2.0 -->

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Gont - A testing framework for distributed Go applications</title>

		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reset.min.css" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/solarized.min.css" />

		<!-- Theme used for syntax highlighted code -->
		<!-- <link rel="stylesheet" href="plugin/highlight/monokai.css"> -->
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/monokai.min.css" integrity="sha512-z8wQkuDRFwCBfoj7KOiu1MECaRVoXx6rZQWL21x0BsVVH7JkqCp1Otf39qve6CrCycOOL5o9vgfII5Smds23rg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

		<style>
			em {
				font-weight: bold;
			}

			code {
				line-height: 1em;
				font-size: 90%;
			}

			li { font-size: 100% }
			li li { font-size: 90% }
			li li li { font-size: 80% }
			li li li li { font-size: 70% }
			li li li li li { font-size: 60% }

			.container{
				display: flex;
			}

			.col{
				flex: 1;
			}

			ul.inline-list li {
				display:inline;
			}

			.smaller {
				font-size: 0.7em;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section>
						<h1>Gont</h1>
						<h3>A testing framework for distributed Go applications</h3>
					</section>

					<section>
						<h2>Introduction</h2>
					</section>

					<section>
						<h3>What does Gont do?</h3>
						<ul>
							<li>Software-defined virtual networking for testing</li>
							<li>Define hosts, switches, routers in a single host</li>
							<li>Reentrancy</li>
							<li>Reproducibility</li>
							<li>Inspired by <a href="http://mininet.org/">Mininet</a></li>
						</ul>
					</section>

					<section>
						<h3>Mininet</h3>
						<div>
							<q>
								Mininet creates a realistic virtual network, running real kernel, switch and application code, on a single machine (VM, cloud or native)
							</q>
							<p>-- <a href="http://mininet.org/">mininet.org</a></p>
						</div>
					</section>

					<section>
						<h3>Mininet</h3>
						<ul>
							<li>Written in Python 2</li>
							<li>Lacking active maintainer</li>
							<li>Focus on SDN: OpenFlow controllers</li>
							<li>No SSL cert on homepage?!</li>
						</ul>
						<div style="margin-top: 2em;"><b>‚Üí</b> We need something better</div>
					</section>

					<section>
						<h3>Why?</h3>
						<ul>
							<li>Describe network topologies quickly in code</li>
							<li>Automate construction of complex topologies</li>
							<li>Unit / CI testing
							<li>Parallel test execution</li>
							<li>Example use-cases
								<ul>
									<li>VPN / network tools development</li>
									<li>SDN Openflow controller development</li>
									<li>cunƒ´cu: zeroconf ‚Ä¢ p2p ‚Ä¢ mesh ‚Ä¢ vpn agent (<a href="https://github.com/stv0g/cunicu">cunƒ´cu</a>)</li>
								</ul>
							</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<p>A little detour:</p>
						<h2>Namespaces</h2>
						<p class="smaller">(Feel free to skip this section if you are<br>only interested in learning about Gont)</p>
					</section>

					<section>
						<h3>What are Linux namespaces?</h3>
					</section>

					<section>
						<h3>They..</h3>
						<ul>
							<li>partition kernel resources<br />from <b>a process-perspective.</b></li>
							<li>power most of Linux containerization tools.</li>
							<li>appear in many Linux subsystems.</li>
							<li>are used by many sandboxing solutions in browsers.</li>
						</ul>
					</section>

					<section>
						<h3>Available Linux namespaces</h3>
						<ul>
							<li><b>mnt:</b> Mounts</li>
							<li><b>pid:</b> Process IDs</li>
							<li><b>net:</b> Networking</li>
							<li><b>ipc:</b> Interprocess Communication</li>
							<li><b>uts:</b> Unix Timesharing (hostname)</li>
							<li><b>user:</b> User identification & privileges</li>
							<li><b>cgroup:</b> Process Control Groups</li>
							<li><b>time:</b> System time</li>
						</ul>
					</section>

					<section>
						<h3>Buts what exactly is a namespace?</h3>
						<ul>
							<li>Can be identified by a file descriptor</li>
							<li>A namespace can have multiple processes assigned to it</li>
							<li>It lives as long as there is still at least one remaining process</li>
							<li>Child processes inherit parent namespaces</li>
						</ul>
					</section>

					<section>
						<h3>How do I create a namespace?</h3>
						<ul>
							<li><a href="https://man7.org/linux/man-pages/man2/unshare.2.html">unshare(2)</a></li>
							<li><a href="https://man7.org/linux/man-pages/man2/clone.2.html">clone(2)</a></li>
						</ul>
					</section>

					<section>
						<h3>unshare(2)</h3>
						<pre><code class="language-go" data-trim >
							func main() {
								err := syscall.Unshare(syscall.CLONE_NEWNS);
							}
						</code></pre>
					</section>

					<section>
						<h3>How do I create a namespace?</h3>
						<pre><code class="language-c" data-trim style="font-size: 10pt;">
							static int child(void *arg) {
								struct utsname uts;

								sethostname(arg, "ernie")

								uname(&uts)
								printf("nodename in child:  %s\n", uts.nodename);

								return 0;
							}

							int main() {
								struct utsname uts;

								/* Allocate stack for child */
								char *stack = malloc(STACK_SIZE);
								if (stack == NULL)
									return -1;

								/* Start new kernel task in new UTS namespace */
								pid_t child_pid = clone(child, stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL);

								/* Output hostname */
								uname(&uts)
								printf("nodename in parent:  %s\n", uts.nodename);
							}
						</code></pre>
					</section>

					<section>
						<h3>How can I share a namespace with other processes?</h3>
						<ul>
							<li>By forking with <a href="https://man7.org/linux/man-pages/man2/clone.2.html">clone(2)</a></li>
							<li>By passing file descriptor and <a href="https://man7.org/linux/man-pages/man2/setns.2.html">setns(2)</a></li>
						</ul>
					</section>

					<section>
						<h3>Joining namespace of another process by <a href="https://man7.org/linux/man-pages/man5/proc.5.html">/proc/{pid}/ns/*</a></h3>
						<pre><code class="language-go" data-trim>
							fd := syscall.Open("/proc/1234/ns/uts", syscall.O_RDONLY);

							err := unix.Setns(fd, syscall.CLONE_NEWUTS);
						</code></pre>
						<b>Note:</b> Can only set a single namespace per <code>netns(2)</code> invocation.
					</section>

					<section>
						<h3>Joining namespace of another process by <a href="https://man7.org/linux/man-pages/man2/pidfd_open.2.html">pidfd_open(2)</a></h3>
						<pre><code class="language-c" data-trim>
							pid_t pid = 1234;
							int fd = pidfd_open(pid, 0);

							setns(fd, CLONE_NEWUTS | CLONE_NEWNET);
						</code></pre>
						<b>Note:</b> Can only set a multiple namespaces per <code>netns(2)</code> invocation.
					</section>

					<section>
						<h3>Persisting namespaces</h3>
						<pre><code class="language-go" data-trim>
							err := syscall.Mount("/proc/self/ns/uts",
							                     "/home/acs/my_uts_namespace", "", syscall.MS_BIND, nil);
						</code></pre>
						<h6>In other process</h6>
						<pre><code data-trim>
							fd := syscall.Open("/home/acs/my_uts_namespace", syscall.O_RDONLY);

							err := unix.Setns(fd, syscall.CLONE_NEWUTS);
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<p>Back to Gont...</p>
						<h2>First some definitions</h2>
					</section>

					<section>
						<dl>
							<dt>network</dt>
							<dd>A set of <em>nodes</em> and <em>links</em> between them</dd>
						</dl>
					</section>

					<section>
						<dl>
							<dt>node</dt>
							<dd>A network namespace which represents any device in the <em>network</em></dd>
						</dl>
					</section>

					<section>
						<dl>
							<dt>link</dt>
							<dd>A pair of <code>veth</code> network interfaces which are associated to separate <em>nodes</em></dd>
						</dl>
					</section>

					<section>
						<dl>
							<dt>interface</dt>
							<dd>an endpoint with one or more assigned IP addresses</dd>
						</dl>
					</section>

					<section>
						<dl>
							<dt>switch</dt>
							<dd>A <em>node</em> containing a Linux layer 2 bridge and attached <em>interfaces</em></dd>
						</dl>
					</section>

					<section>
						<dl>
							<dt>host</dt>
							<dd>A <em>node</em> with several configured <em>interfaces</em></dd>
						</dl>
					</section>

					<section>
						<dl>
							<dt>router</dt>
							<dd>A <em>host</em> with IP forwarding enabled</dd>
						</dl>
					</section>

					<section>
						<dl>
							<dt>nat</dt>
							<dd>A special type of <em>router</em> which implements network address translation between a set of south- and north-bound <em>interfaces</em></dd>
						</dl>
					</section>

					<section>
						<h3>Relationships</h3>
						<img class="stretch" src="images/architecture.svg" />
					</section>

					<section>
						<h3>Gont and Namespaces</h3>
						<ul>
							<li>for each <em>node</em>:
								<ul>
									<li>a separate network namespace</em></li>
									<li>a separate uts namespace
										<ul>
											<li>for a unique hostname within each <em>node</em></li>
										</ul>
									</li>

								</ul>
							</li>
							<li>for each <em>network</em>:
								<ul>
									<li>a separate mount namespace</li>
										<ul>
											<li>for a unique <code>/etc/hosts</code> files between <em>networks</em></li>
										</ul>
									</ul>
							</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Examples</h2>
						<h3>Show me some code!</h3>
						<p class="smaller">
							<b>‚ö†Ô∏è Warning:</b> Please note that these examples are show<br>just for demonstration purposes and might not compile.
						</p>
					</section>

					<section>
						<h3>Detailed examples</h3>
						<p class="smaller">
							Have a look at the following code for full fledged test/example code:
						</p>
						<ul class="smaller">
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/ping_test.go">Ping</a></li>
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/run_test.go">Run</a></li>
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/nat_test.go">NAT</a></li>
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/switch_test.go">Switch</a></li>
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/link_test.go">Links</a></li>
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/filter_test.go">Firewall Rules</a></li>
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/capture_test.go">Packet Tracing</a></li>
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/trace_test.go">Event Tracing</a></li>
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/capture_keylog_test.go">Tracing with TLS decryption</a></li>
							<li><a href="https://github.com/stv0g/gont/blob/master/pkg/debug_test.go">Debugger</a></li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Basic networking</h2>
					</section>

					<section>
						<h3>Two directly connected hosts</h3>
						<pre><code class="language-go" data-trim>
							import g "github.com/stv0g/gont/v2/pkg"
							import o "github.com/stv0g/gont/v2/pkg/options"

							...

							n, _ := g.NewNetwork("mynet")

							h1, _ := n.AddHost("h1")
							h2, _ := n.AddHost("h2")

							n.AddLink(
								g.NewInterface("eth0", h1, o.AddressIP("10.0.0.1/24")),
								g.NewInterface("eth0", h2, o.AddressIP("10.0.0.2/24")),
							)

							h1.Ping(h2)
						</code></pre>
						<p style="font-size: smaller;">(We use <code>g</code> and <code>o</code> throughout these examples as import aliases)</p>
					</section>

					<section>
						<h3>Lets add a L2 switch</h3>
						<pre><code class="language-go" data-trim>
							sw, _ := n.AddSwitch("sw")

							h1, _ := n.AddHost("h1",
								g.NewInterface("eth0", sw,
									o.AddressIP("10.0.0.1/24")))

							h2, _ := n.AddHost("h2",
								g.NewInterface("eth0", sw,
									o.AddressIP("10.0.0.2/24")))

							h1.Ping(h2)
						</code></pre>
					</section>

					<section>
						<h3>How about a L3 router?</h3>
						<pre><code class="language-go" data-trim>
							sw1, _ := n.AddSwitch("sw1")
							sw2, _ := n.AddSwitch("sw2")

							h1, _ := n.AddHost("h1", g.NewInterface("eth0", sw1,
							                    o.AddressIP("10.0.0.2/24")))
							h2, _ := n.AddHost("h2", g.NewInterface("eth0", sw2,
							                    o.AddressIP("10.0.1.2/24")))

							n.AddRouter("r1",
								g.NewInterface("eth0", sw, o.AddressIP("10.0.0.1/24")),
								g.NewInterface("eth1", sw, o.AddressIP("10.0.1.1/24"))
							)

							h1.Ping(h2)
						</code></pre>
					</section>

					<section>
						<h3>Lets do some evil NATing üòà</h3>
						<pre><code class="language-go" data-trim>
							sw1, _ := n.AddSwitch("sw1")
							sw2, _ := n.AddSwitch("sw2")

							h1, _ := n.AddHost("h1", g.NewInterface("eth0", sw1,
							                    o.AddressIP("10.0.0.2/24")))
							h2, _ := n.AddHost("h2", g.NewInterface("eth0", sw2,
							                    o.AddressIP("10.0.1.2/24")))

							n.AddNAT("n1",
								g.NewInterface("eth0", sw, o.SouthBound,
								             o.AddressIP("10.0.0.1/24")),
								g.NewInterface("eth1", sw, o.NorthBound,
								             o.AddressIP("10.0.1.1/24")))

							h1.Ping(h2)
						</code></pre>
					</section>

					<section>
						<h3>How about a whole chain of routers?</h3>
						<pre><code class="language-go" data-trim>
							var firstSwitch *g.Switch = n.AddSwitch("sw0")
							var lastSwitch  *g.Switch = nil

							for i := 1; i < 100; i++ {
								swName := fmt.Printf("sw%d", i)
								rtrName := fmt.Printf("r%d", i)

								newSwitch, _ := n.AddSwitch(swName)

								n.AddRouter(rtrName,
									g.NewInterface("eth0", lastSwitch,
									             o.AddressIP("10.0.0.1/24")),
									g.NewInterface("eth1", newSwitch,
									             o.AddressIP("10.0.1.1/24"))
								)

								lastSwitch = newSwitch
							}

							h1, _ := n.AddHost("h1", g.NewInterface("eth0", firstSwitch,
							                    o.AddressIP("10.0.0.2/24")))
							h2, _ := n.AddHost("h2", g.NewInterface("eth0", lastSwitch,
							                    o.AddressIP("10.0.1.2/24")))

							h1.Ping(h2)
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Running your application</h2>
						<p>Inside the network namespaces / hosts</p>
					</section>

					<section>
						<h3>exec.Cmd API</h3>
						<pre><code class="language-go" data-trim>
							// Get a exec.Cmd-like struct
							cmd := h1.Command("ping", "h2")
							out, err := cmd.CombinedOutput()

							// Directly run a simple process synchronously
							cmd, err := h1.Run("ping", "h2")

							// Directly start asynchronously
							cmd, err := h1.Start("ping", "h2")

							time.Sleep(5 * time.Second)

							err = cmd.Process.Signal(os.Interrupt)
							cmd.Wait()
						</code></pre>
						<p style="font-size: smaller;">The <code>g.Node</code> type implements an API similar to the one provided by Go's <code>exec</code> package.</p>
					</section>

					<section>
						<h3>Pass options</h3>

						<pre><code class="language-go" data-trim>
							import co "github.com/stv0g/gont/v2/pkg/options/cmd"

							outb := &bytes.Buffer{}

							cmd := h1.Command("ping", "1.1.1.1",
								co.DisableASLR(true),
								co.Dir("/custom/working/dir"),
								co.EnvVar("DEBUG", "1"),
								co.Stdin(...), // pass any io.Reader
								co.Stdout(outb), // pass any io.Writer (can be repeated)
								co.Stderr(...), // pass any io.Writer (can be repeated)
							)

							print(outb.String())
						</code></pre>
					</section>

					<section>
						<h3>Pass non-string arguments</h3>

						<pre><code class="language-go" data-trim>
							ip := net.ParseIP("1.1.1.1")

							cmd := h1.Command("ping", "-c", 10, "-i", 0.1, ip)
						</code></pre>
					</section>

					<section>
						<h3>Go functions</h3>

						<pre><code class="language-go" data-trim>
							h1.RunFunc(func() {
								r := http.Get("http://h2:8080")
								io.Copy(os.Stdout, r.Body)
							})
						</code></pre>

						<p style="font-size: 0.7em;">
							Call a function inside a network namespace
							of host <code>h1</code> but still<br>in the same process
							so you can use channels and access global variables.
						</p>

						<p class="smaller" style="margin-top: 3em;">
							<b>‚ö†Ô∏è Warning:</b> Spawning Goroutines from within the callback<br>is only indirectly supported:</b>
						</p>
						
						<pre><code class="language-go" data-trim>
							h1.RunFunc(func() {
								go h1.RunFunc(func() { ... })
							})
						</code></pre>
					</section>

					<section>
						<h3>Go packages</h3>
						<pre><code class="language-go" data-trim>
							cmd, err := h1.RunGo("test/prog.go", "arg1")
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Firewall</h2>
						<p>by Netfilter's nftables</p>
					</section>

					<section>
						<h3>Add some firewall rules for a host</h3>
						<pre><code class="language-go" data-trim>
							import fo "github.com/stv0g/gont/v2/options/filter"

							_, src, _ := net.ParseCIDR("10.0.0.1/32")

							h1, _ := n.AddHost("h1",
												o.Filter(
													g.FilterInput,
														fo.Source(src),
														fo.Protocol(unix.AF_INET),
														fo.TransportProtocol(unix.IPPROTO_TCP),
														fo.SourcePortRange(0, 1024)))
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Network Emulation</h2>
						<p>by Linux's Traffic Control: Netem Qdisc</p>
					</section>

					<section>
						<h3>Attach a netem Qdisc to an interface</h3>
						<pre><code class="language-go" data-trim>
							import tco "github.com/stv0g/gont/v2/options/tc"

							n.AddLink(
								g.NewInterface("eth0", h1,
									o.WithNetem(
										tco.Latency(50 * time.Millisecond),
										tco.Jitter(5 * time.Millisecond),
										tco.Loss(0.1),
									),
									o.AddressIP("10.0.0.1/24")),
								g.NewInterface("eth0", h2,
									o.AddressIP("10.0.0.2/24")),
							)

							h1.Ping(h2)
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Packet captures</h2>
						<p>PCAP, WireShark, tshark</p>
					</section>

					<section>
						<h3>Write to packets to</h3>
						
						<p style="font-size: 0.7em;">Gont merges and sorts packet captures in real-time<br>from multiple interfaces and records them to one of the following sinks:</p>
						
						<ul style="font-size: 0.7em;">
							<li>Using <a href="https://github.com/pcapng/pcapng">PCAPng</a> format
								<ul>
									<li>Regular files</li>
									<li>Named pipes</li>
									<li>TCP / UDP / Unix listeners</li>
									<li>WireShark real-time stream</li>
								</ul>
							</li>
							<li>Go channels</li>
							<li>Go callback functions.</li>
						</ul>
					</section>

					<section>
						<h3>Filtering</h3>
						<p>Captured network traffic can be filtered by</p>
						<ul>
							<li>Selected Gont nodes and interfaces</li>
							<li>eBPF filter programs</li>
							<li><a href="https://www.tcpdump.org/manpages/pcap-filter.7.html">pcap-filter(7)</a> expressions</li>
							<li>Go callback functions (‚ö† slow!)</li>
						</ul>
					</section>

					<section>
						<h3>Session key logging</h3>
						<p>Most transport layer encryption protocols today provide <a href="https://en.wikipedia.org/wiki/Forward_secrecy">perfect forward secrecy</a> by using short-lived ephemeral session keys.</p>
						<p>Gont offers a feature to log these session keys into a PCAPng file to enable a decryption of upper layer protocols with a dissector tool like Wireshark.</p>
					</section>

					<section>
						<h3>Example</h3>
						<img src="images/session-key-logging.png" />
					</section>
				</section>

				<section>
					<section>
						<h2>Distributed Tracing</h2>
						<p>User defined events, Log messages</p>
					</section>

					<section>
						<h3>A trace event</h3>

						<p class="smaller">Gont supports collecting trace events from all processes running in a distributed system which can carry the following information. Gont orders trace events by time and saves them to different destinations for analysis.</p>

						<pre><code class="language-go" data-trim>
							type Event struct {
								Timestamp time.Time	// Timestamp when the event occurred
								Type      string    // Either: 'log', ÃÅ'trace', 'break' & ÃÅ watchpoint'
								Level     uint8     // Log level
								Message   string    // A human readable description
								Source    string    // Logger name
								PID       int 
								Function  string
								File      string
								Line      int
								Args      []any
								Data      any       // User defined data
							}
						</code></pre>
					</section>

					<section>
						<h3>Write to trace events to</h3>
						<ul>
							<li>JSON files</li>
							<li>Go channels</li>
							<li>Go callbacks</li>
							<li>Packet captures</li>
						</ul>
					</section>

					<section>
						<h3>Create a tracer</h3>

						<pre><code class="language-go" data-trim>
							import "github.com/stv0g/gont/v2/trace"
							import to "github.com/stv0g/gont/v2/options/trace"

							c := g.NewCapture(...)
							f, _ := os.OpenFile(...)
							ch := make(chan trace.Event)

							t := g.NewTracer(
								to.ToFile(f)
								to.ToFilename("trace.log"),
								to.ToChannel(ch),
								to.ToCapture(c),
								to.Callback(func(e trace.Event) { ... }))

							t.Start()
						</code></pre>
					</section>

					<section>
						<h3>Attach the tracer</h3>
						
						<p class="smaller">Trace all processes started by nodes of this network</p>
						<pre style="margin-bottom: 2em;"><code class="language-go" data-trim>
							n, _ := g.NewNetwork("", t)
						</code></pre>

						<p class="smaller">Trace all processes started by a node</p>
						<pre style="margin-bottom: 2em;"><code class="language-go" data-trim>
							h1 := n.NewHost("h1", t)
						</code></pre>

						<p class="smaller">Trace a single process</p>
						<pre style="margin-bottom: 2em;"><code class="language-go" data-trim>
							h1.RunGo("test/main.go", t)
						</code></pre>

					</section>

					<section>
						<h3>Trace with trace package</h3>
						<pre><code class="language-go" data-trim>
							import "github.com/stv0g/gont/v2/pkg/trace"

							someData := map[string]string{"Hello": "World"}
							count := 42

							trace.Start(0)

							trace.PrintfWithData(someData, "Count is: %d", count)
							trace.Print("Another message")

							trace.Stop()
						</code></pre>

						<p class="smaller" style="margin-top: 3em;">Works from:</p>
						<ul class="smaller">
							<li>Gont process itself</li>
							<li>Any process spawned via Gont's<br>
								<code>Host.{Command,Run,RunGo,Start,StartGo}(...)</code> functions</li>
						</ul>
					</section>

					<section>
						<h3>Trace via slog structured logging package</h3>

						<pre><code class="language-go" data-trim>
							import "golang.org/x/exp/slog"
							import "github.com/stv0g/gont/v2/pkg/trace"

							// Create a slog handler which emits trace events
							handler := trace.NewTraceHandler(slog.HandlerOptions{})

							// Add the tracing option which emits a trace event for each log message
							logger := slog.New(handler)
						</code></pre>

						<p class="smaller" style="margin-top: 3em;">
							Each log message emits a trace event which includes the log message, filename, line number as well function name and more.<br>
							Any fields passed to to zap structured logger are included in the <code>Data</code> field of the <code>Event</code> structure.
						</p>
					</section>

					<section>
						<h3>Trace via zap logging package</h3>

						<pre><code class="language-go" data-trim>
							import "go.uber.org/zap"
							import "github.com/stv0g/gont/v2/pkg/trace"

							// Add the tracing option which emits a trace event for each log message
							logger := zap.NewDevelopment(trace.Log())

							// Add the caller info which gets also included in the trace event
							logger = logger.WithOptions(zap.AddCaller())

							// Give the logger some name which is added as the Source field to the trace event
							logger = logger.Named("my-test-logger")
						</code></pre>

						<p class="smaller" style="margin-top: 3em;">
							Each log message emits a trace event which includes the log message, filename, line number as well function name and more.<br>
							Any fields passed to to zap structured logger are included in the <code>Data</code> field of the <code>Event</code> structure.
						</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Distributed Debugging</h2>
						<p>powered by Delve</p>
					</section>

					<section>
						<h3>Introduction</h3>
						<p class="smaller">
							Gont can manage Delve debugger instances attached to spawned sub-processes.
							These Delve instances can be used to debug or trace multiple applications in a distributed system simultaneously.
							Users can either use DAP-compatible IDEs like VScode to attach to those processes, or record tracepoint data generated by Delve break- & watchpoints to a PCAPng file.
						</p>
						<p class="smaller">
							Its integration with the packet capture and event tracing feature of Gont allows the user to even streaming tracepoint data interleaved with packet and other tracing data in real-time to Wireshark.
						</p>
					</section>

					<section>
						<h3>Create a debugger</h3>

						<pre><code class="language-go" data-trim>
							import do "github.com/stv0g/gont/v2/pkt/options/debug"

							t := g.NewTracer(...)

							d := g.NewDebugger(
								// ... Tracepoints are defined her
								do.BreakOnEntry(true),
								do.ListenAddr("tcp:[::]:1234"), // DAP listening socket
								do.ToTracer(t))
						</code></pre>
					</section>

					<section>
						<h3>Attach a debugger</h3>

						<p class="smaller">Debug all processes started by nodes of this network:</p>
						<pre style="margin-bottom: 2em;"><code class="language-go" data-trim>
							n, _ := g.NewNetwork("", d)
						</code></pre>

						<p class="smaller">Debug all processes started by a node:</p>
						<pre style="margin-bottom: 2em;"><code class="language-go" data-trim>
							h1 := n.NewHost("h1", d)
						</code></pre>

						<p class="smaller">Debug a single process:</p>
						<pre style="margin-bottom: 2em;"><code class="language-go" data-trim>
							h1.RunGo("test/main.go", d)
						</code></pre>

						<p class="smaller">(Like for the event tracing)</p>
					</section>

					<section>
						<h3>Define tracepoints</h3>
						<h5>Break-, watchpoint location</h5>

						<pre><code class="language-go" data-trim>
							import "github.com/go-delve/delve/service/api"
							import do "github.com/stv0g/gont/v2/pkt/options/debug"

							d := g.NewDebugger(
								g.NewTracepoint(
									do.Disabled(false),
									do.Name("tp1"),
									do.Message("A trace message with evaluated {placeholders}"),
									do.Location(...), // A Delve locspec
									do.Address(0x12312321),
									do.File("main.go"),
									do.Line(12),
									do.FunctionName("main.main"),
									do.FunctionNameRegex("main\.(main|setupLogger)"),
									do.Condition("i % 100 == 0"),
									do.HitCondition("> 100"),
									do.HitConditionPerGoroutine(true),
									do.Watch("p", api.WatchRead|api.WatchWrite),
								),
								...
							)
						</code></pre>
					</section>

					<section>
						<h3>Define tracepoints</h3>
						<h5>Gathering of breakpoint information</h5>

						<pre><code class="language-go" data-trim>
							import do "github.com/stv0g/gont/v2/pkt/options/debug"

							d := g.NewDebugger(
								g.NewTracepoint(
									...
									do.Variable("j"),
									do.Goroutine(true),
									do.Stacktrace(10),
									do.LoadLocals(...),
									do.LoadArguments(
										do.FollowPointers(true),
										do.MaxVariableRecurse(3),
										do.MaxStringLen(128),
										do.MaxArrayValues(128),
										do.MaxStructFields(32),
									)
								)
							)
						</code></pre>
					</section>

					<section>
						<h3>VSCode Integration</h3>

						<p class="smaller">Gont generates VS Code launch compound configurations based on the active debugging sessions.</p>

						<pre><code class="language-go" data-trim>
							d.WriteVSCodeConfigs("", false)
						</code></pre>
					</section>
				</section>

				<section>
					<h3>Topology factories (WIP)</h3>
					<pre><code class="language-go" data-trim>
						createHost := func(pos int) (*g.Host. error) {
							return n.AddHost(fmt.Sprintf("h%d", pos))
						}

						linkHosts := func(a, b *g.Node) error {
							_, err := n.AddRouter(fmt.Sprintf("r%d", pos),
								g.NewInterface("eth0", a, o.AddressIPv4(10, 0, 0, a.Position, 24),
								g.NewInterface("eth1", b, o.AddressIPv4(10, 0, 0, b.Position, 24)
							)
							return err
						}

						topo.Linear(n, 100, createHost, linkHosts)

						n.Nodes["h0"].Traceroute(n.Nodes["h99"])
					</code></pre>
				</section>

				<section>
					<section>
						<h2>CLI utility</h2>
					</section>
					<section>
						<h3>CLI Example</h3>
						<p>Make network persistent</p>
						<pre><code class="language-go" data-trim>
							n, _ := g.NewNetwork("mynet", o.Persistent(true))
						</code></pre>

						<p>Introspect network after creation with <code>gontc</code></p>
						<pre><code class="language-bash" data-trim>
							$ gontc list
							mynet

							$ gontc list mynet
							mynet/h1
							mynet/h2

							$ gontc exec mynet/h1 hostname
							h1.mynet.gont

							$ gontc shell mynet/h1
							$ mynet/h1: ip address show
						</code></pre>
					</section>
					<section>
						<h3>CLI Usage</h3>
						<pre><code class="language-text" data-trim style="font-size: 12pt; line-height: 1em;">
							Usage: gontc [flags] &lt;command&gt;

								Supported &lt;commands&gt; are:

								  identify                               return the network and node name if gontc is executed within a network namespace
								  shell [&lt;net&gt;]/&lt;node&gt;                   get an interactive shell inside &lt;node&gt;
								  exec  [&lt;net&gt;]/&lt;node&gt; &lt;command&gt; [args]  executes a &lt;command&gt; in the namespace of &lt;node&gt; with optional [args]
								  list  [&lt;net&gt;]                          list all active Gont networks or nodes of a given network
								  clean [&lt;net&gt;]                          removes the all or just the specified Gont network
								  help                                   show this usage information
								  version                                shows the version of Gont

							   Example:

								  gontc exec zorn/h1 ping h2

							   Gont - The Go network tester
								  Author Steffen Vogel &lt;post@steffenvogel&gt;
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>How do I use it?</h2>
					</section>
					<section>
						<h3>Gont ...</h3>
						<ul>
							<li>can be used in Go unit &amp; integration-tests
								<ul>
									<li>on Github-powered CI runners</li>
								</ul>
							</li>
							<li>is licensed under Apache-2.0</li>
							<li>is available at <a href="https://github.com/stv0g/gont">github.com/stv0g/gont</a></li>
							<li>is documented at <a href="https://pkg.go.dev/github.com/stv0g/gont">pkg.go.dev/github.com/stv0g/gont</a></li>
							<li>has slides at <a href="https://stv0g.github.io/gont">stv0g.github.io/gont</a></li>
						</ul>
					</section>
					<section>
						<h3>Requirements</h3>
						<ul>
							<li>Go 1.19</li>
							<li>A moderate recent Linux kernel (>= 4.9)
								<ul>
									<li><code>mnt</code> and <code>net</code> namespace support</li>
								</ul>
							</li>
							<li>root access / <code>NET_ADMIN</code> caps</li>
							<li>traceroute userspace tool</li>
							<li>libpcap for packet captures</li>
						</ul>
					</section>
					<section>
						<h3>Roadmap</h3>
						<ul>
							<li>Use pure Go implementation of traceroute</li>
							<li>More topology factories</li>
							<li>Design a nice logo</li>
							<li>A Graphviz output for topology visualization</li>
							<li>Automatic address assignment</li>
							<li>Parser for network topologies from <a href="https://graphviz.org/doc/info/lang.html">Dot</a>, <a href="https://yaml.org/">YAML</a> or <a href="https://www.json.org/">JSON</a> description.</li>
						</ul>
					</section>
					<section>
						<h4>Dot example</h4>
						<div class="container">
							<div class="col">
								<pre><code style="font-size: 90%" data-trim >
									digraph D {
										/* network options */
										persistent = true

										/* nodes */
										h1 [type=host, exec="ping h2"]
										h2 [type=host]
										r1 [type=router]

										/* links */
										h1 -> r1 [address="10.0.0.1/24",
										          mtu=9000]
										h2 -> r1 [address="10.0.0.2/24",
										          mtu=9000]
									}
								</code></pre>
							</div>
							<div class="col">
								<img src="images/graphviz.svg" />
							</div>
						</div>
					</section>
				</section>

				<section>
					<h3>Thanks for your attention</h3>
					<p>Steffen Vogel</p>
					<div style="font-size: 70%;">
						<p>
							<a href="https://github.com/stv0g/gont">@stv0g</a>,
							<a href="mailto:stv0g@0l.de">stv0g@0l.de</a>
						</p>
					</div>
					<div style="margin: 4em auto 0; width: 50%;">
						<a href="https://www.acs.eonerc.rwth-aachen.de">
							<img alt="EONERC Logo" src="https://fein-aachen.org/img/logos/eonerc.png" />
						</a>
					</div>
					<div style="margin: 0 auto; width: 50%;">
						<img alt="European Flag"
							src="https://erigrid2.eu/wp-content/uploads/2020/03/europa_flag_low.jpg"
							style="float: left; margin: 0" />
						<p style="font-size: 12pt;">
							The development of Gont has been supported by the <a href="https://erigrid2.eu">ERIGrid 2.0</a> project of the H2020 Programme under <a href="https://cordis.europa.eu/project/id/870620">Grant Agreement No. 870620</a>.
						</p>
					</div>
				</div>
				</section>
			</div>
		</div>

		<script src="plugin/highlight/highlight.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js"></script>

		<!-- Extra languages for highlight.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js" integrity="sha512-Ea+IN1qMvgwTqOnwxM38Hn54IaDS2buEvMJNTdSB5JOT4njx3RvPij353zbUMpT+zYjDqQDr2UbrbnW5+wE54A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// The "normal" size of the presentation, aspect ratio will
				// be preserved when the presentation is scaled to fit different
				// resolutions. Can be specified using percentage units.
				width: 1024,

				// Factor of the display size that should remain empty around
				// the content
				margin: 0.05,

				// Bounds for smallest/largest possible scale to apply to content
				minScale: 0.2,
				maxScale: 2.0,

				slideNumber: "h.v",
				showSlideNumber: "speaker",

				// Help the user learn the controls by providing hints, for example by
				// bouncing the down arrow when they first encounter a vertical slide
				controlsTutorial: true,

				// Determines where controls appear, "edges" or "bottom-right"
				controlsLayout: 'edges',

				// Learn about plugins: https://revealjs.com/plugins/
				// plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
				plugins: [ RevealHighlight ]
			});
		</script>
	</body>
</html>
